package qdr

import (
	"fmt"
	"github.com/skupperproject/skupper/api/types"
	"github.com/skupperproject/skupper/pkg/qdr"
	"github.com/skupperproject/skupper/pkg/utils"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kubetypes "k8s.io/apimachinery/pkg/types"
	"strings"
	"testing"

	"gotest.tools/assert"
)

func TestEnableTlsSupport(t *testing.T) {

	var tests = []struct {
		name          string
		tlsSupport    TlsServiceSupport
		tlsManager    TlsManagerInterface
		expectedError string
	}{
		{
			name: "Service does not need TLS support",
			tlsSupport: TlsServiceSupport{
				Address: "service1",
			},
			tlsManager: nil, //not called
		},
		{
			name: "Certificates should be generated by Skupper, the secret and the profile do not exist in the cluster",
			tlsSupport: TlsServiceSupport{
				Address:     "service2",
				Credentials: types.SkupperServiceCertPrefix + "service2",
			},
			tlsManager: MockTlsManager{
				GetSecretResult:     "error",
				GetConfigMapResult:  "ok",
				NewSecretResult:     "ok",
				AddSslProfileResult: "ok",
			},
		},
		{
			name: "Certificates are generated by Skupper, the secret already exists cluster",
			tlsSupport: TlsServiceSupport{
				Address:     "service3",
				Credentials: types.SkupperServiceCertPrefix + "service3",
			},
			tlsManager: MockTlsManager{
				GetSecretResult: "ok",
			},
		},
		{
			name: "Certificates are generated by Skupper, error getting the config map",
			tlsSupport: TlsServiceSupport{
				Address:     "service3",
				Credentials: types.SkupperServiceCertPrefix + "service3",
			},
			tlsManager: MockTlsManager{
				GetSecretResult:    "error",
				GetConfigMapResult: "error",
			},
			expectedError: "error getting the configmap",
		},
		{
			name: "Certificates are generated by Skupper, error creating the new secret",
			tlsSupport: TlsServiceSupport{
				Address:     "service",
				Credentials: types.SkupperServiceCertPrefix + "service",
			},
			tlsManager: MockTlsManager{
				GetSecretResult:    "error",
				GetConfigMapResult: "ok",
				NewSecretResult:    "error",
			},
			expectedError: "error creating the secret",
		},
		{
			name: "Certificates are generated by Skupper, error adding ssl profile",
			tlsSupport: TlsServiceSupport{
				Address:     "service",
				Credentials: types.SkupperServiceCertPrefix + "service",
			},
			tlsManager: MockTlsManager{
				GetSecretResult:     "error",
				GetConfigMapResult:  "ok",
				NewSecretResult:     "ok",
				AddSslProfileResult: "error",
			},
			expectedError: "error adding the ssl profile",
		},
		{
			name: "Certificates are customised, but the secret with the CA does not exist in the cluster",
			tlsSupport: TlsServiceSupport{
				Address:       "service",
				Credentials:   "custom-credentials-service",
				CertAuthority: "custom-credentials-service-ca",
			},
			tlsManager: MockTlsManager{
				GetSecretResult:        "failsOnlySearchingByCA",
				ExistsSslProfileResult: "false",
				AddSslProfileResult:    "ok",
			},
			expectedError: "The secret custom-credentials-service-ca for address service is missing",
		},
		{
			name: "Certificates are customised and the credentials and CA secrets exist and the sslProfile does not need to be added",
			tlsSupport: TlsServiceSupport{
				Address:       "service",
				Credentials:   "custom-credentials-service",
				CertAuthority: "custom-credentials-service-ca",
			},
			tlsManager: MockTlsManager{
				GetSecretResult:        "ok",
				GetConfigMapResult:     "ok",
				ExistsSslProfileResult: "true",
			},
		},
		{
			name: "Certificates are customised and the credentials and CA secrets exist and the sslProfile needs to be added",
			tlsSupport: TlsServiceSupport{
				Address:       "service",
				Credentials:   "custom-credentials-service",
				CertAuthority: "custom-credentials-service-ca",
			},
			tlsManager: MockTlsManager{
				GetSecretResult:        "ok",
				GetConfigMapResult:     "ok",
				ExistsSslProfileResult: "false",
				AddSslProfileResult:    "ok",
			},
		},
		{
			name: "Fails when checking the sslProfile in the router config",
			tlsSupport: TlsServiceSupport{
				Address:       "service",
				Credentials:   "custom-credentials-service",
				CertAuthority: "custom-credentials-service-ca",
			},
			tlsManager: MockTlsManager{
				GetSecretResult:        "ok",
				GetConfigMapResult:     "ok",
				ExistsSslProfileResult: "error",
			},
			expectedError: "Error checking if if credentials exist in the router config",
		},
	}
	for _, test := range tests {

		fmt.Println(test.name)
		err := EnableTlsSupport(test.tlsSupport, test.tlsManager)
		if test.expectedError != "" {
			assert.Error(t, err, test.expectedError, test.name)
		}

	}
}

func TestDisableTlsSupport(t *testing.T) {

	var tests = []struct {
		name           string
		tlsCredentials string
		tlsManager     TlsManagerInterface
		expectedError  string
	}{
		{
			name:           "Service does not need TLS support",
			tlsCredentials: "",
		},
		{
			name:           "Certificates are generated by Skupper, the secret and the profile should be deleted",
			tlsCredentials: types.SkupperServiceCertPrefix + "service2",
			tlsManager: MockTlsManager{
				GetSecretResult:        "ok",
				RemoveSslProfileResult: "ok",
				DeleteSecretResult:     "ok",
			},
		},
		{
			name:           "Certificates are customised, the profile and secrets should not be deleted",
			tlsCredentials: "custom-service",
		},
		{
			name:           "It should not fail when trying to delete a secret that is not available",
			tlsCredentials: types.SkupperServiceCertPrefix + "service2",
			tlsManager: MockTlsManager{
				GetSecretResult:        "error",
				RemoveSslProfileResult: "ok",
			},
		},
		{
			name:           "It should return and error if it was not possible to remove the sslProfile",
			tlsCredentials: types.SkupperServiceCertPrefix + "service2",
			tlsManager: MockTlsManager{
				RemoveSslProfileResult: "error",
			},
			expectedError: "error removing skupper-tls-service2",
		},
		{
			name:           "It should return an error if deleting a secret has failed",
			tlsCredentials: types.SkupperServiceCertPrefix + "service2",
			tlsManager: MockTlsManager{
				GetSecretResult:        "ok",
				RemoveSslProfileResult: "ok",
				DeleteSecretResult:     "error",
			},
			expectedError: "error deleting skupper-tls-service2",
		},
	}
	for _, test := range tests {

		fmt.Println(test.name)
		err := DisableTlsSupport(test.tlsCredentials, test.tlsManager)
		if test.expectedError != "" {
			assert.Error(t, err, test.expectedError, test.name)
		}

	}
}

type MockTlsManager struct {
	GetSecretResult        string
	GetConfigMapResult     string
	NewSecretResult        string
	ExistsSslProfileResult string
	AddSslProfileResult    string
	RemoveSslProfileResult string
	DeleteSecretResult     string
}

func (mock MockTlsManager) GetSecret(name string) (*corev1.Secret, error) {
	switch mock.GetSecretResult {
	case "ok":
		secret := corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name: name,
			},
		}
		return &secret, nil
	case "error":
		return nil, fmt.Errorf("secret %s do not exist", name)
	case "failsOnlySearchingByCA":
		if strings.Contains(name, "ca") {
			return nil, fmt.Errorf("secret %s do not exist", name)
		} else {
			secret := corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name: name,
				},
			}
			return &secret, nil
		}
	default:
		return nil, nil
	}

}

func (mock MockTlsManager) GetConfigMap() (*corev1.ConfigMap, error) {
	switch mock.GetConfigMapResult {
	case "ok":
		configMap := corev1.ConfigMap{
			ObjectMeta: metav1.ObjectMeta{
				Name: types.TransportConfigMapName,
				UID:  kubetypes.UID(utils.RandomId(5)),
			},
		}
		return &configMap, nil
	case "error":
		return nil, fmt.Errorf("error getting the configmap")
	default:
		return nil, nil
	}
}

func (mock MockTlsManager) NewSecret(credential types.Credential, ownerReference *metav1.OwnerReference) (*corev1.Secret, error) {
	switch mock.NewSecretResult {
	case "ok":
		secret := corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name: credential.Name,

				OwnerReferences: []metav1.OwnerReference{
					{
						Name: ownerReference.Name,
					},
				},
			},
		}

		return &secret, nil
	case "error":
		return nil, fmt.Errorf("error creating the secret")
	default:
		return nil, nil
	}
}

func (mock MockTlsManager) AddSslProfile(sslProfile qdr.SslProfile) error {
	switch mock.AddSslProfileResult {
	case "ok":
		return nil
	case "error":
		return fmt.Errorf("error adding the ssl profile")
	default:
		return nil
	}
}

func (mock MockTlsManager) ExistsSslProfile(sslProfile string) (bool, error) {
	switch mock.ExistsSslProfileResult {
	case "true":
		return true, nil
	case "false":
		return false, nil
	case "error":
		return false, fmt.Errorf("error searching for %s sslProfile", sslProfile)
	default:
		return false, nil
	}
}

func (mock MockTlsManager) RemoveSslProfile(sslProfile string) error {
	switch mock.RemoveSslProfileResult {
	case "ok":
		return nil
	case "error":
		return fmt.Errorf("error removing %s", sslProfile)
	default:
		return nil
	}
}

func (mock MockTlsManager) DeleteSecret(secretName string) error {
	switch mock.DeleteSecretResult {
	case "ok":
		return nil
	case "error":
		return fmt.Errorf("error deleting %s", secretName)
	default:
		return nil
	}
}
