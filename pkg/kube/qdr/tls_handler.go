package qdr

import (
	"fmt"
	"github.com/skupperproject/skupper/api/types"
	"github.com/skupperproject/skupper/pkg/qdr"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"strings"
)

type GetSecretFunc func(string) (*corev1.Secret, error)
type GetConfigMapFunc func() (*corev1.ConfigMap, error)
type NewSecretFunc func(types.Credential, *metav1.OwnerReference) (*corev1.Secret, error)
type DeleteSecretFunc func(string) error
type AddSslProfileFunc func(sslProfile qdr.SslProfile) error
type ExistsSslProfileFunc func(string) (bool, error)
type RemoveSslProfileFunc func(string) error

type TlsSupport struct {
	Address       string
	Credentials   string
	CertAuthority string
}

func EnableTlsSupport(support TlsSupport, getSecret GetSecretFunc, getConfigMap GetConfigMapFunc, newSecret NewSecretFunc, addSslProfile AddSslProfileFunc, existsSslProfile ExistsSslProfileFunc) error {

	if support.Credentials != "" {
		if isGeneratedBySkupper(support.Credentials) {
			// If the requested certificate is one generated by skupper it can be generated in other sites as well
			_, err := getSecret(support.Credentials)
			if err != nil {
				serviceSecret, err := generateNewSecret(support, getConfigMap, newSecret)
				if err != nil {
					return err
				}

				return includeSslProfile(qdr.SslProfile{Name: serviceSecret.Name}, addSslProfile)
			}
		} else {
			_, err := getSecret(support.Credentials)
			if err != nil {
				return fmt.Errorf("The secret %s for address %s is missing", support.Credentials, support.Address)
			}

			err = checkAndIncludeSslProfile(qdr.SslProfile{Name: support.Credentials}, addSslProfile, existsSslProfile)
			if err != nil {
				return err
			}
		}
	}

	if support.CertAuthority != "" && support.CertAuthority != types.ServiceClientSecret {
		_, err := getSecret(support.CertAuthority)
		if err != nil {
			return fmt.Errorf("The secret %s for address %s is missing", support.CertAuthority, support.Address)
		}

		sslProfile := qdr.SslProfile{
			Name:       support.CertAuthority,
			CaCertFile: fmt.Sprintf("/etc/skupper-router-certs/%s/ca.crt", support.CertAuthority),
		}

		err = checkAndIncludeSslProfile(sslProfile, addSslProfile, existsSslProfile)
		if err != nil {
			return err
		}
	}

	return nil
}

func DisableTlsSupport(credentials string, removeSslProfile RemoveSslProfileFunc, getSecret GetSecretFunc, deleteSecret DeleteSecretFunc) error {
	if len(credentials) > 0 {
		if isGeneratedBySkupper(credentials) {
			err := removeSslProfile(credentials)
			if err != nil {
				return err
			}

			_, err = getSecret(credentials)
			if err == nil {
				err = deleteSecret(credentials)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func includeSslProfile(sslProfile qdr.SslProfile, addSslProfile AddSslProfileFunc) error {
	errAddSslProfile := addSslProfile(sslProfile)
	if errAddSslProfile != nil {
		return errAddSslProfile
	}
	return nil
}

func checkAndIncludeSslProfile(sslProfile qdr.SslProfile, addSsl AddSslProfileFunc, checkIfExists ExistsSslProfileFunc) error {
	ok, err := checkIfExists(sslProfile.Name)

	if err != nil {
		return fmt.Errorf("Error checking if if credentials exist in the router config")
	}

	if !ok {
		return includeSslProfile(sslProfile, addSsl)
	}

	return nil
}

func generateNewSecret(support TlsSupport, getConfigMap GetConfigMapFunc, newSecret NewSecretFunc) (*corev1.Secret, error) {
	configmap, err := getConfigMap()

	if err != nil {
		return nil, err
	}

	serviceCredential := types.Credential{
		CA:          types.ServiceCaSecret,
		Name:        support.Credentials,
		Subject:     support.Address,
		Hosts:       []string{support.Address},
		ConnectJson: false,
		Post:        false,
	}

	ownerReference := metav1.OwnerReference{
		APIVersion: "v1",
		Kind:       "ConfigMap",
		Name:       configmap.Name,
		UID:        configmap.UID,
	}
	serviceSecret, err := newSecret(serviceCredential, &ownerReference)

	if err != nil {
		return nil, err
	}

	return serviceSecret, nil
}

func isGeneratedBySkupper(credentials string) bool {
	return strings.HasPrefix(credentials, types.SkupperServiceCertPrefix)
}
