package qdr

import (
	"fmt"
	"github.com/skupperproject/skupper/api/types"
	"github.com/skupperproject/skupper/pkg/kube"
	"github.com/skupperproject/skupper/pkg/qdr"
	"github.com/skupperproject/skupper/pkg/service"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"strings"
)

type TlsManagerInterface interface {
	GetSecret(string) (*corev1.Secret, error)
	GetConfigMap() (*corev1.ConfigMap, error)
	NewSecret(types.Credential, *metav1.OwnerReference) (*corev1.Secret, error)
	DeleteSecret(string) error
	AddSslProfile(sslProfile qdr.SslProfile) error
	ExistsSslProfile(string) (bool, error)
	RemoveSslProfile(string) error
}

type TlsServiceSupport struct {
	Address       string
	Credentials   string
	CertAuthority string
}

func EnableTlsSupport(support TlsServiceSupport, tlsManager TlsManagerInterface) error {

	if support.Credentials != "" {
		if isGeneratedBySkupper(support.Credentials) {
			// If the requested certificate is one generated by skupper it can be generated in other sites as well
			_, err := tlsManager.GetSecret(support.Credentials)
			if err != nil {
				serviceSecret, err := generateNewSecret(support, tlsManager)
				if err != nil {
					return err
				}

				return includeSslProfile(qdr.SslProfile{Name: serviceSecret.Name}, tlsManager)
			}
		} else {
			_, err := tlsManager.GetSecret(support.Credentials)
			if err != nil {
				return fmt.Errorf("The secret %s for address %s is missing", support.Credentials, support.Address)
			}

			err = checkAndIncludeSslProfile(qdr.SslProfile{Name: support.Credentials}, tlsManager)
			if err != nil {
				return err
			}
		}
	}

	if support.CertAuthority != "" && support.CertAuthority != types.ServiceClientSecret {
		_, err := tlsManager.GetSecret(support.CertAuthority)
		if err != nil {
			return fmt.Errorf("The secret %s for address %s is missing", support.CertAuthority, support.Address)
		}

		sslProfile := qdr.SslProfile{
			Name:       support.CertAuthority,
			CaCertFile: fmt.Sprintf("/etc/skupper-router-certs/%s/ca.crt", support.CertAuthority),
		}

		err = checkAndIncludeSslProfile(sslProfile, tlsManager)
		if err != nil {
			return err
		}
	}

	return nil
}

func DisableTlsSupport(credentials string, tlsManager TlsManagerInterface) error {
	if len(credentials) > 0 {
		if isGeneratedBySkupper(credentials) {
			err := tlsManager.RemoveSslProfile(credentials)
			if err != nil {
				return err
			}

			_, err = tlsManager.GetSecret(credentials)
			if err == nil {
				err = tlsManager.DeleteSecret(credentials)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func CheckBindingSecrets(services map[string]*service.ServiceBindings, namespace string, cli kubernetes.Interface) error {
	for _, service := range services {

		if service.TlsCredentials != "" {
			_, err := cli.CoreV1().Secrets(namespace).Get(service.TlsCredentials, metav1.GetOptions{})
			if err != nil {
				return fmt.Errorf("SslProfile %s for service %s does not exist in this cluster", service.TlsCredentials, service.Address)
			}
		}

		if service.TlsCertAuthority != "" {
			_, err := cli.CoreV1().Secrets(namespace).Get(service.TlsCertAuthority, metav1.GetOptions{})
			if err != nil {
				return fmt.Errorf("SslProfile %s for service %s does not exist in this cluster", service.TlsCertAuthority, service.Address)
			}
		}
	}
	return nil
}

func includeSslProfile(sslProfile qdr.SslProfile, tlsManager TlsManagerInterface) error {
	errAddSslProfile := tlsManager.AddSslProfile(sslProfile)
	if errAddSslProfile != nil {
		return errAddSslProfile
	}
	return nil
}

func checkAndIncludeSslProfile(sslProfile qdr.SslProfile, tlsManager TlsManagerInterface) error {
	ok, err := tlsManager.ExistsSslProfile(sslProfile.Name)

	if err != nil {
		return fmt.Errorf("Error checking if if credentials exist in the router config")
	}

	if !ok {
		return includeSslProfile(sslProfile, tlsManager)
	}

	return nil
}

func generateNewSecret(support TlsServiceSupport, tlsManager TlsManagerInterface) (*corev1.Secret, error) {
	configmap, err := tlsManager.GetConfigMap()

	if err != nil {
		return nil, err
	}

	serviceCredential := types.Credential{
		CA:          types.ServiceCaSecret,
		Name:        support.Credentials,
		Subject:     support.Address,
		Hosts:       []string{support.Address},
		ConnectJson: false,
		Post:        false,
	}

	ownerReference := metav1.OwnerReference{
		APIVersion: "v1",
		Kind:       "ConfigMap",
		Name:       configmap.Name,
		UID:        configmap.UID,
	}
	serviceSecret, err := tlsManager.NewSecret(serviceCredential, &ownerReference)

	if err != nil {
		return nil, err
	}

	return serviceSecret, nil
}

func isGeneratedBySkupper(credentials string) bool {
	return strings.HasPrefix(credentials, types.SkupperServiceCertPrefix)
}

type TlsManager struct {
	KubeClient kubernetes.Interface
	Namespace  string
}

func (manager *TlsManager) GetSecret(name string) (*corev1.Secret, error) {
	return manager.KubeClient.CoreV1().Secrets(manager.Namespace).Get(name, metav1.GetOptions{})
}

func (manager *TlsManager) GetConfigMap() (*corev1.ConfigMap, error) {
	return manager.KubeClient.CoreV1().ConfigMaps(manager.Namespace).Get(types.TransportConfigMapName, metav1.GetOptions{})
}

func (manager *TlsManager) NewSecret(credential types.Credential, ownerReference *metav1.OwnerReference) (*corev1.Secret, error) {
	return kube.NewSecret(credential, ownerReference, manager.Namespace, manager.KubeClient)
}

func (manager *TlsManager) AddSslProfile(sslProfile qdr.SslProfile) error {
	return AddSslProfile(sslProfile, manager.Namespace, manager.KubeClient)
}

func (manager *TlsManager) ExistsSslProfile(sslProfile string) (bool, error) {
	return ExistsSslProfile(sslProfile, manager.Namespace, manager.KubeClient)
}

func (manager *TlsManager) RemoveSslProfile(sslProfile string) error {
	return RemoveSslProfile(sslProfile, manager.Namespace, manager.KubeClient)
}

func (manager *TlsManager) DeleteSecret(secretName string) error {
	return manager.KubeClient.CoreV1().Secrets(manager.Namespace).Delete(secretName, &metav1.DeleteOptions{})
}
