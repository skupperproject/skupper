package main

import (
	"fmt"
	"github.com/skupperproject/skupper/api/types"
	"github.com/skupperproject/skupper/pkg/utils"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kubetypes "k8s.io/apimachinery/pkg/types"
	"strings"
	"testing"

	"gotest.tools/assert"
)

func TestEnableTlsSupport(t *testing.T) {

	mockGetConfigMap := MockGetConfigMapFunc{}
	mockGetSecret := MockGetSecretFunc{}
	mockNewSecret := MockNewSecretFunc{}
	mockAddSslProfile := MockAddSslProfileFunc{}
	mockExistsSslProfile := MockExistsSslProfileFunc{}

	var tests = []struct {
		name             string
		tlsSupport       TlsSupport
		getSecret        GetSecretFunc
		getConfigMap     GetConfigMapFunc
		newSecret        NewSecretFunc
		addSslProfile    AddSslProfileFunc
		existsSslProfile ExistsSslProfileFunc
		expectedError    string
	}{
		{
			name: "Service does not need TLS support",
			tlsSupport: TlsSupport{
				address: "service1",
			},
			getSecret:     nil, //func not called
			getConfigMap:  nil, //func not called
			newSecret:     nil, //func not called
			addSslProfile: nil, //func not called
		},
		{
			name: "Certificates should be generated by Skupper, the secret and the profile do not exist in the cluster",
			tlsSupport: TlsSupport{
				address:     "service2",
				credentials: types.SkupperServiceCertPrefix + "service2",
			},
			getSecret:     mockGetSecret.error,
			getConfigMap:  mockGetConfigMap.ok,
			newSecret:     mockNewSecret.ok,
			addSslProfile: mockAddSslProfile.ok,
		},
		{
			name: "Certificates are generated by Skupper, the secret already exists cluster",
			tlsSupport: TlsSupport{
				address:     "service3",
				credentials: types.SkupperServiceCertPrefix + "service3",
			},
			getSecret:     mockGetSecret.ok,
			getConfigMap:  nil, //func not called
			newSecret:     nil, //func not called
			addSslProfile: nil, //func not called
		},
		{
			name: "Certificates are generated by Skupper, error getting the config map",
			tlsSupport: TlsSupport{
				address:     "service3",
				credentials: types.SkupperServiceCertPrefix + "service3",
			},
			getSecret:     mockGetSecret.error,
			getConfigMap:  mockGetConfigMap.error,
			newSecret:     nil, //func not called
			addSslProfile: nil, //func not called
			expectedError: "error getting the configmap",
		},
		{
			name: "Certificates are generated by Skupper, error creating the new secret",
			tlsSupport: TlsSupport{
				address:     "service",
				credentials: types.SkupperServiceCertPrefix + "service",
			},
			getSecret:     mockGetSecret.error,
			getConfigMap:  mockGetConfigMap.ok,
			newSecret:     mockNewSecret.error,
			addSslProfile: nil, //func not called
			expectedError: "error creating the secret",
		},
		{
			name: "Certificates are generated by Skupper, error adding ssl profile",
			tlsSupport: TlsSupport{
				address:     "service",
				credentials: types.SkupperServiceCertPrefix + "service",
			},
			getSecret:     mockGetSecret.error,
			getConfigMap:  mockGetConfigMap.ok,
			newSecret:     mockNewSecret.ok,
			addSslProfile: mockAddSslProfile.error,
			expectedError: "error adding the ssl profile",
		},
		{
			name: "Certificates are customised, but the secret with the CA does not exist in the cluster",
			tlsSupport: TlsSupport{
				address:       "service",
				credentials:   "custom-credentials-service",
				certAuthority: "custom-credentials-service-ca",
			},
			getSecret:        mockGetSecret.failsOnlySearchingByCA,
			getConfigMap:     nil, //func not called
			newSecret:        nil, //func not called
			existsSslProfile: mockExistsSslProfile.false,
			addSslProfile:    mockAddSslProfile.ok,
			expectedError:    "The secret custom-credentials-service-ca is missing",
		},
		{
			name: "Certificates are customised and the credentials and CA secrets exist and the sslProfile does not need to be added",
			tlsSupport: TlsSupport{
				address:       "service",
				credentials:   "custom-credentials-service",
				certAuthority: "custom-credentials-service-ca",
			},
			getSecret:        mockGetSecret.ok,
			getConfigMap:     mockGetConfigMap.ok,
			newSecret:        nil, //func not called
			existsSslProfile: mockExistsSslProfile.true,
			addSslProfile:    nil, //func not called
		},
		{
			name: "Certificates are customised and the credentials and CA secrets exist and the sslProfile needs to be added",
			tlsSupport: TlsSupport{
				address:       "service",
				credentials:   "custom-credentials-service",
				certAuthority: "custom-credentials-service-ca",
			},
			getSecret:        mockGetSecret.ok,
			getConfigMap:     mockGetConfigMap.ok,
			newSecret:        nil, //func not called
			existsSslProfile: mockExistsSslProfile.false,
			addSslProfile:    mockAddSslProfile.ok,
		},
		{
			name: "Fails when checking the sslProfile in the router config",
			tlsSupport: TlsSupport{
				address:       "service",
				credentials:   "custom-credentials-service",
				certAuthority: "custom-credentials-service-ca",
			},
			getSecret:        mockGetSecret.ok,
			getConfigMap:     mockGetConfigMap.ok,
			newSecret:        nil, //func not called
			existsSslProfile: mockExistsSslProfile.error,
			addSslProfile:    nil, //func not called
			expectedError:    "Error checking if if credentials exist in the router config",
		},
	}
	for _, test := range tests {

		fmt.Println(test.name)
		err := EnableTlsSupport(test.tlsSupport, test.getSecret, test.getConfigMap, test.newSecret, test.addSslProfile, test.existsSslProfile)
		if test.expectedError != "" {
			assert.Error(t, err, test.expectedError, test.name)
		}

	}
}

func TestDisableTlsSupport(t *testing.T) {

	mockGetSecret := MockGetSecretFunc{}
	mockDeleteSecret := MockDeleteSecretFunc{}
	mockRemoveSslProfile := MockRemoveSslProfileFunc{}

	var tests = []struct {
		name             string
		tlsSupport       TlsSupport
		removeSslProfile RemoveSslProfileFunc
		getSecret        GetSecretFunc
		deleteSecret     DeleteSecretFunc
		expectedError    string
	}{
		{
			name: "Service does not need TLS support",
			tlsSupport: TlsSupport{
				address: "service1",
			},
			getSecret:        nil, //func not called
			removeSslProfile: nil, //func not called
			deleteSecret:     nil, //func not called
		},
		{
			name: "Certificates are generated by Skupper, the secret and the profile should be deleted (not CA)",
			tlsSupport: TlsSupport{
				address:     "service2",
				credentials: types.SkupperServiceCertPrefix + "service2",
			},
			getSecret:        mockGetSecret.ok,
			removeSslProfile: mockRemoveSslProfile.ok,
			deleteSecret:     mockDeleteSecret.ok,
		},
		{
			name: "Certificates are customised, the profile should be deleted (for both credentials and CA) but not the secrets",
			tlsSupport: TlsSupport{
				address:       "service2",
				credentials:   "custom-service",
				certAuthority: "custom-service-ca",
			},
			getSecret:        nil, //func not called
			removeSslProfile: mockRemoveSslProfile.ok,
			deleteSecret:     nil, //func not called
		},
		{
			name: "Certificates are customised, the profile should be deleted for CA but not the secrets",
			tlsSupport: TlsSupport{
				address:       "service2",
				certAuthority: "custom-service-ca",
			},
			getSecret:        nil, //func not called
			removeSslProfile: mockRemoveSslProfile.ok,
			deleteSecret:     nil, //func not called
		},
		{
			name: "Certificates are generated by Skupper, the skupper-service-client CA should remain as secret and sslProfile",
			tlsSupport: TlsSupport{
				address:       "service2",
				certAuthority: types.ServiceClientSecret,
			},
			getSecret:        nil, //func not called
			removeSslProfile: nil, //func not called
			deleteSecret:     nil, //func not called
		},
		{
			name: "It should not fail when trying to delete a secret that is not available",
			tlsSupport: TlsSupport{
				address:     "service2",
				credentials: types.SkupperServiceCertPrefix + "service2",
			},
			getSecret:        mockGetSecret.error,
			removeSslProfile: mockRemoveSslProfile.ok, //func not called
			deleteSecret:     nil,
		},
		{
			name: "It should return and error if it was not possible to remove the sslProfile",
			tlsSupport: TlsSupport{
				address:     "service2",
				credentials: types.SkupperServiceCertPrefix + "service2",
			},
			getSecret:        nil, //func not called
			removeSslProfile: mockRemoveSslProfile.error,
			deleteSecret:     nil,
			expectedError:    "error removing skupper-tls-service2",
		},
		{
			name: "It should not remove generic skupper-service-client profile",
			tlsSupport: TlsSupport{
				address:       "service2",
				certAuthority: types.ServiceClientSecret,
			},
			getSecret:        nil, //func not called
			removeSslProfile: nil, //func not called
			deleteSecret:     nil, //func not called
		},
		{
			name: "It should remove cert authority but the secret should remain",
			tlsSupport: TlsSupport{
				address:       "service2",
				certAuthority: "custom-service-ca",
			},
			getSecret:        nil, //func not called
			removeSslProfile: mockRemoveSslProfile.ok,
			deleteSecret:     nil,
		},
		{
			name: "It should return an error if deleting a secret has failed",
			tlsSupport: TlsSupport{
				address:     "service2",
				credentials: types.SkupperServiceCertPrefix + "service2",
			},
			getSecret:        mockGetSecret.ok, //func not called
			removeSslProfile: mockRemoveSslProfile.ok,
			deleteSecret:     mockDeleteSecret.error,
			expectedError:    "error deleting skupper-tls-service2",
		},
	}
	for _, test := range tests {

		fmt.Println(test.name)
		err := DisableTlsSupport(test.tlsSupport, test.removeSslProfile, test.getSecret, test.deleteSecret)
		if test.expectedError != "" {
			assert.Error(t, err, test.expectedError, test.name)
		}

	}
}

// Mocks for the functions that are going to be passed as parameters
type MockGetSecretFunc struct{}

func (m MockGetSecretFunc) ok(secretname string) (*corev1.Secret, error) {
	secret := corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name: secretname,
		},
	}
	return &secret, nil
}
func (m MockGetSecretFunc) error(secretname string) (*corev1.Secret, error) {
	return nil, fmt.Errorf("secret %s do not exist", secretname)
}

func (m MockGetSecretFunc) failsOnlySearchingByCA(secretname string) (*corev1.Secret, error) {
	if strings.Contains(secretname, "ca") {
		return m.error(secretname)
	} else {
		return m.ok(secretname)
	}
}

type MockGetConfigMapFunc struct{}

func (m MockGetConfigMapFunc) ok() (*corev1.ConfigMap, error) {
	configMap := corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name: types.TransportConfigMapName,
			UID:  kubetypes.UID(utils.RandomId(5)),
		},
	}

	return &configMap, nil
}
func (m MockGetConfigMapFunc) error() (*corev1.ConfigMap, error) {
	return nil, fmt.Errorf("error getting the configmap")
}

type MockNewSecretFunc struct{}

func (m MockNewSecretFunc) ok(credential types.Credential, ownerRef *metav1.OwnerReference) (*corev1.Secret, error) {
	secret := corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name: credential.Name,

			OwnerReferences: []metav1.OwnerReference{
				{
					Name: ownerRef.Name,
				},
			},
		},
	}

	return &secret, nil
}
func (m MockNewSecretFunc) error(credential types.Credential, ownerRef *metav1.OwnerReference) (*corev1.Secret, error) {

	return nil, fmt.Errorf("error creating the secret")
}

type MockAddSslProfileFunc struct{}

func (m MockAddSslProfileFunc) ok(sslProfile string) error {
	return nil
}
func (m MockAddSslProfileFunc) error(sslProfile string) error {
	return fmt.Errorf("error adding the ssl profile")
}

type MockExistsSslProfileFunc struct{}

func (m MockExistsSslProfileFunc) true(sslProfile string) (bool, error) {
	return true, nil
}
func (m MockExistsSslProfileFunc) false(sslProfile string) (bool, error) {
	return false, nil
}

func (m MockExistsSslProfileFunc) error(sslProfile string) (bool, error) {
	return false, fmt.Errorf("error searching for %s sslProfile", sslProfile)
}

type MockDeleteSecretFunc struct{}

func (m MockDeleteSecretFunc) ok(secretName string) error {
	return nil
}
func (m MockDeleteSecretFunc) error(secretName string) error {
	return fmt.Errorf("error deleting %s", secretName)
}

type MockRemoveSslProfileFunc struct{}

func (m MockRemoveSslProfileFunc) ok(sslProfile string) error {
	return nil
}

func (m MockRemoveSslProfileFunc) error(sslProfile string) error {
	return fmt.Errorf("error removing %s", sslProfile)
}
