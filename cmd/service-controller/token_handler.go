package main

import (
	"context"
	"strconv"

	corev1 "k8s.io/api/core/v1"

	"github.com/skupperproject/skupper/api/types"
	"github.com/skupperproject/skupper/client"
	"github.com/skupperproject/skupper/pkg/event"
)

type TokenHandler struct {
	name      string
	vanClient *client.VanClient
	siteId    string
}

func (h *TokenHandler) Handle(name string, token *corev1.Secret) error {
	if token != nil {
		if h.isTokenValidInSite(token) {
			return h.connect(token)
		}
		return nil
	} else {
		return h.disconnect(name)
	}
}

func newTokenHandler(cli *client.VanClient, siteId string) *SecretController {
	handler := &TokenHandler{
		name:      "TokenHandler",
		vanClient: cli,
		siteId:    siteId,
	}
	return NewSecretController(handler.name, types.TypeTokenQualifier, cli.KubeClient, cli.Namespace, handler)
}

func (c *TokenHandler) getTokenCost(token *corev1.Secret) (int32, bool) {
	if token.ObjectMeta.Annotations == nil {
		return 0, false
	}
	if costString, ok := token.ObjectMeta.Annotations[types.TokenCost]; ok {
		cost, err := strconv.Atoi(costString)
		if err != nil {
			event.Recordf(c.name, "Ignoring invalid cost annotation %q", costString)
			return 0, false
		}
		return int32(cost), true
	}
	return 0, false
}

func (c *TokenHandler) connect(token *corev1.Secret) error {
	event.Recordf(c.name, "Connecting using token %s", token.ObjectMeta.Name)
	var options types.ConnectorCreateOptions
	options.Name = token.ObjectMeta.Name
	options.SkupperNamespace = c.vanClient.Namespace
	if cost, ok := c.getTokenCost(token); ok {
		options.Cost = cost
	}
	return c.vanClient.ConnectorCreate(context.Background(), token, options)
}

func (c *TokenHandler) disconnect(name string) error {
	event.Recordf(c.name, "Disconnecting connector %s", name)
	var options types.ConnectorRemoveOptions
	options.Name = name
	options.SkupperNamespace = c.vanClient.Namespace
	// Secret has already been deleted so force update to current active secrets
	options.ForceCurrent = true
	return c.vanClient.ConnectorRemove(context.Background(), options)
}

func (c *TokenHandler) isTokenValidInSite(token *corev1.Secret) bool {
	if author, ok := token.ObjectMeta.Annotations[types.TokenGeneratedBy]; ok && author == c.siteId {
		//token was generated by this site so should not be applied
		return false
	} else {
		return true
	}
}
